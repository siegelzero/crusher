## FlatZinc parser - lexer + recursive descent parser producing FznModel AST.
## Handles the subset of FlatZinc generated by MiniZinc 2.9.x compilers.

import std/[strutils, strformat]

type
  FznSolveKind* = enum
    Satisfy, Minimize, Maximize

  FznAnnotation* = object
    name*: string
    args*: seq[FznExpr]

  FznExprKind* = enum
    FznIntLit, FznBoolLit, FznStringLit, FznIdent, FznArrayLit,
    FznSetLit, FznRange, FznAnnotationExpr

  FznExpr* = ref object
    case kind*: FznExprKind
    of FznIntLit:
      intVal*: int
    of FznBoolLit:
      boolVal*: bool
    of FznStringLit:
      strVal*: string
    of FznIdent:
      ident*: string
    of FznArrayLit:
      elems*: seq[FznExpr]
    of FznSetLit:
      setElems*: seq[int]
    of FznRange:
      lo*, hi*: int
    of FznAnnotationExpr:
      annName*: string
      annArgs*: seq[FznExpr]

  FznTypeKind* = enum
    FznInt, FznBool, FznIntRange, FznIntSet, FznSetOfInt, FznSetOfIntRange

  FznType* = object
    case kind*: FznTypeKind
    of FznInt, FznBool:
      discard
    of FznIntRange:
      lo*, hi*: int
    of FznIntSet:
      values*: seq[int]
    of FznSetOfInt:
      discard
    of FznSetOfIntRange:
      setLo*, setHi*: int

  FznVarDecl* = object
    name*: string
    varType*: FznType
    isVar*: bool
    isArray*: bool
    arraySize*: int         # for arrays, the count
    annotations*: seq[FznAnnotation]
    value*: FznExpr         # nil if no RHS assignment

  FznConstraint* = object
    name*: string
    args*: seq[FznExpr]
    annotations*: seq[FznAnnotation]

  FznSolve* = object
    kind*: FznSolveKind
    objective*: FznExpr     # nil for satisfy
    annotations*: seq[FznAnnotation]

  FznModel* = object
    parameters*: seq[FznVarDecl]
    variables*: seq[FznVarDecl]
    constraints*: seq[FznConstraint]
    solve*: FznSolve

  # Lexer token types
  TokenKind = enum
    TkInt, TkFloat, TkIdent, TkString, TkBool,
    TkLParen, TkRParen, TkLBrack, TkRBrack, TkLBrace, TkRBrace,
    TkComma, TkSemicolon, TkColon, TkColonColon, TkDotDot, TkEq,
    TkVar, TkArray, TkOf, TkConstraint, TkSolve, TkSatisfy,
    TkMinimize, TkMaximize, TkPredicate, TkInt_kw, TkBool_kw,
    TkSet, TkTrue, TkFalse,
    TkEof

  Token = object
    kind: TokenKind
    intVal: int
    strVal: string
    line: int

  Lexer = object
    src: string
    pos: int
    line: int

  Parser = object
    tokens: seq[Token]
    pos: int

# ============================================================================
# Lexer
# ============================================================================

proc initLexer(src: string): Lexer =
  Lexer(src: src, pos: 0, line: 1)

proc atEnd(lex: Lexer): bool {.inline.} =
  lex.pos >= lex.src.len

proc peek(lex: Lexer): char {.inline.} =
  if lex.atEnd: '\0' else: lex.src[lex.pos]

proc advance(lex: var Lexer): char {.inline.} =
  result = lex.src[lex.pos]
  inc lex.pos
  if result == '\n': inc lex.line

proc skipWhitespaceAndComments(lex: var Lexer) =
  while not lex.atEnd:
    let c = lex.peek
    if c in {' ', '\t', '\r', '\n'}:
      discard lex.advance
    elif c == '%':
      # Line comment
      while not lex.atEnd and lex.peek != '\n':
        discard lex.advance
    else:
      break

proc readNumber(lex: var Lexer): Token =
  var s = ""
  let startLine = lex.line
  if lex.peek == '-':
    s.add(lex.advance)
  while not lex.atEnd and lex.peek in {'0'..'9'}:
    s.add(lex.advance)
  # Check for float (we parse but store as int for FlatZinc integer models)
  if not lex.atEnd and lex.peek == '.' and lex.pos + 1 < lex.src.len and lex.src[lex.pos + 1] in {'0'..'9'}:
    s.add(lex.advance) # '.'
    while not lex.atEnd and lex.peek in {'0'..'9'}:
      s.add(lex.advance)
    return Token(kind: TkFloat, strVal: s, line: startLine)
  Token(kind: TkInt, intVal: parseInt(s), line: startLine)

proc readIdentOrKeyword(lex: var Lexer): Token =
  var s = ""
  let startLine = lex.line
  while not lex.atEnd and lex.peek in {'a'..'z', 'A'..'Z', '0'..'9', '_'}:
    s.add(lex.advance)
  case s
  of "var": Token(kind: TkVar, strVal: s, line: startLine)
  of "array": Token(kind: TkArray, strVal: s, line: startLine)
  of "of": Token(kind: TkOf, strVal: s, line: startLine)
  of "constraint": Token(kind: TkConstraint, strVal: s, line: startLine)
  of "solve": Token(kind: TkSolve, strVal: s, line: startLine)
  of "satisfy": Token(kind: TkSatisfy, strVal: s, line: startLine)
  of "minimize": Token(kind: TkMinimize, strVal: s, line: startLine)
  of "maximize": Token(kind: TkMaximize, strVal: s, line: startLine)
  of "predicate": Token(kind: TkPredicate, strVal: s, line: startLine)
  of "int": Token(kind: TkInt_kw, strVal: s, line: startLine)
  of "bool": Token(kind: TkBool_kw, strVal: s, line: startLine)
  of "set": Token(kind: TkSet, strVal: s, line: startLine)
  of "true": Token(kind: TkTrue, strVal: s, line: startLine)
  of "false": Token(kind: TkFalse, strVal: s, line: startLine)
  else: Token(kind: TkIdent, strVal: s, line: startLine)

proc readString(lex: var Lexer): Token =
  let startLine = lex.line
  discard lex.advance  # opening "
  var s = ""
  while not lex.atEnd and lex.peek != '"':
    if lex.peek == '\\':
      discard lex.advance
      if not lex.atEnd:
        s.add(lex.advance)
    else:
      s.add(lex.advance)
  if not lex.atEnd:
    discard lex.advance  # closing "
  Token(kind: TkString, strVal: s, line: startLine)

proc tokenize(src: string): seq[Token] =
  var lex = initLexer(src)
  while true:
    lex.skipWhitespaceAndComments()
    if lex.atEnd:
      result.add(Token(kind: TkEof, line: lex.line))
      break
    let c = lex.peek
    case c
    of '0'..'9':
      result.add(lex.readNumber())
    of '-':
      if lex.pos + 1 < lex.src.len and lex.src[lex.pos + 1] in {'0'..'9'}:
        result.add(lex.readNumber())
      else:
        # Just a minus sign as part of identifier or something unexpected
        discard lex.advance
    of 'a'..'z', 'A'..'Z', '_':
      result.add(lex.readIdentOrKeyword())
    of '"':
      result.add(lex.readString())
    of '(':
      result.add(Token(kind: TkLParen, line: lex.line))
      discard lex.advance
    of ')':
      result.add(Token(kind: TkRParen, line: lex.line))
      discard lex.advance
    of '[':
      result.add(Token(kind: TkLBrack, line: lex.line))
      discard lex.advance
    of ']':
      result.add(Token(kind: TkRBrack, line: lex.line))
      discard lex.advance
    of '{':
      result.add(Token(kind: TkLBrace, line: lex.line))
      discard lex.advance
    of '}':
      result.add(Token(kind: TkRBrace, line: lex.line))
      discard lex.advance
    of ',':
      result.add(Token(kind: TkComma, line: lex.line))
      discard lex.advance
    of ';':
      result.add(Token(kind: TkSemicolon, line: lex.line))
      discard lex.advance
    of ':':
      discard lex.advance
      if not lex.atEnd and lex.peek == ':':
        discard lex.advance
        result.add(Token(kind: TkColonColon, line: lex.line))
      else:
        result.add(Token(kind: TkColon, line: lex.line))
    of '.':
      discard lex.advance
      if not lex.atEnd and lex.peek == '.':
        discard lex.advance
        result.add(Token(kind: TkDotDot, line: lex.line))
      # else: skip lone dot
    of '=':
      result.add(Token(kind: TkEq, line: lex.line))
      discard lex.advance
    else:
      # Skip unknown characters
      discard lex.advance

# ============================================================================
# Parser
# ============================================================================

proc initParser(tokens: seq[Token]): Parser =
  Parser(tokens: tokens, pos: 0)

proc cur(p: Parser): Token {.inline.} =
  if p.pos < p.tokens.len: p.tokens[p.pos]
  else: Token(kind: TkEof, line: 0)

proc curKind(p: Parser): TokenKind {.inline.} = p.cur.kind

proc eat(p: var Parser): Token {.inline.} =
  result = p.cur
  inc p.pos

proc expect(p: var Parser, kind: TokenKind): Token =
  if p.curKind != kind:
    raise newException(ValueError,
      &"FZN parse error at line {p.cur.line}: expected {kind}, got {p.curKind} ('{p.cur.strVal}')")
  p.eat()

proc tryEat(p: var Parser, kind: TokenKind): bool =
  if p.curKind == kind:
    inc p.pos
    true
  else:
    false

# Forward declarations
proc parseExpr(p: var Parser): FznExpr
proc parseAnnotations(p: var Parser): seq[FznAnnotation]

proc parseExpr(p: var Parser): FznExpr =
  case p.curKind
  of TkInt:
    let tok = p.eat()
    # Check for range: int..int
    if p.curKind == TkDotDot:
      discard p.eat()
      let hi = p.expect(TkInt)
      return FznExpr(kind: FznRange, lo: tok.intVal, hi: hi.intVal)
    return FznExpr(kind: FznIntLit, intVal: tok.intVal)
  of TkTrue:
    discard p.eat()
    return FznExpr(kind: FznBoolLit, boolVal: true)
  of TkFalse:
    discard p.eat()
    return FznExpr(kind: FznBoolLit, boolVal: false)
  of TkString:
    let tok = p.eat()
    return FznExpr(kind: FznStringLit, strVal: tok.strVal)
  of TkIdent:
    let tok = p.eat()
    # Check if it's a function-like call: name(args)
    if p.curKind == TkLParen:
      discard p.eat()  # (
      var args: seq[FznExpr]
      if p.curKind != TkRParen:
        args.add(p.parseExpr())
        while p.tryEat(TkComma):
          args.add(p.parseExpr())
      discard p.expect(TkRParen)
      return FznExpr(kind: FznAnnotationExpr, annName: tok.strVal, annArgs: args)
    return FznExpr(kind: FznIdent, ident: tok.strVal)
  of TkLBrack:
    discard p.eat()  # [
    var elems: seq[FznExpr]
    if p.curKind != TkRBrack:
      elems.add(p.parseExpr())
      while p.tryEat(TkComma):
        elems.add(p.parseExpr())
    discard p.expect(TkRBrack)
    return FznExpr(kind: FznArrayLit, elems: elems)
  of TkLBrace:
    discard p.eat()  # {
    var vals: seq[int]
    if p.curKind != TkRBrace:
      vals.add(p.expect(TkInt).intVal)
      while p.tryEat(TkComma):
        vals.add(p.expect(TkInt).intVal)
    discard p.expect(TkRBrace)
    return FznExpr(kind: FznSetLit, setElems: vals)
  else:
    raise newException(ValueError,
      &"FZN parse error at line {p.cur.line}: unexpected token {p.curKind}")

proc parseAnnotations(p: var Parser): seq[FznAnnotation] =
  while p.curKind == TkColonColon:
    discard p.eat()  # ::
    let name = p.expect(TkIdent).strVal
    var args: seq[FznExpr]
    if p.curKind == TkLParen:
      discard p.eat()
      if p.curKind != TkRParen:
        args.add(p.parseExpr())
        while p.tryEat(TkComma):
          args.add(p.parseExpr())
      discard p.expect(TkRParen)
    result.add(FznAnnotation(name: name, args: args))

proc parseType(p: var Parser): (FznType, bool) =
  ## Returns (type, isVar)
  var isVar = false
  if p.curKind == TkVar:
    isVar = true
    discard p.eat()

  # Check for set of
  if p.curKind == TkSet:
    discard p.eat()
    discard p.expect(TkOf)
    if p.curKind == TkInt:
      let lo = p.eat().intVal
      if p.curKind == TkDotDot:
        discard p.eat()
        let hi = p.expect(TkInt).intVal
        return (FznType(kind: FznSetOfIntRange, setLo: lo, setHi: hi), isVar)
    return (FznType(kind: FznSetOfInt), isVar)

  case p.curKind
  of TkInt_kw:
    discard p.eat()
    return (FznType(kind: FznInt), isVar)
  of TkBool_kw:
    discard p.eat()
    return (FznType(kind: FznBool), isVar)
  of TkInt:
    let lo = p.eat().intVal
    discard p.expect(TkDotDot)
    let hi = p.expect(TkInt).intVal
    return (FznType(kind: FznIntRange, lo: lo, hi: hi), isVar)
  of TkLBrace:
    discard p.eat()
    var vals: seq[int]
    if p.curKind != TkRBrace:
      vals.add(p.expect(TkInt).intVal)
      while p.tryEat(TkComma):
        vals.add(p.expect(TkInt).intVal)
    discard p.expect(TkRBrace)
    return (FznType(kind: FznIntSet, values: vals), isVar)
  else:
    raise newException(ValueError,
      &"FZN parse error at line {p.cur.line}: unexpected type token {p.curKind}")

proc parseVarDecl(p: var Parser): FznVarDecl =
  ## Parses variable or parameter declaration
  var isArray = false
  var arraySize = 0

  # Check for array declaration
  if p.curKind == TkArray:
    isArray = true
    discard p.eat()  # array
    discard p.expect(TkLBrack)
    let lo = p.expect(TkInt).intVal
    discard p.expect(TkDotDot)
    let hi = p.expect(TkInt).intVal
    arraySize = hi - lo + 1
    discard p.expect(TkRBrack)
    discard p.expect(TkOf)

  let (varType, isVar) = p.parseType()

  discard p.expect(TkColon)
  let name = p.expect(TkIdent).strVal

  # Parse annotations before '='
  let annotations = p.parseAnnotations()

  # Optional '= value'
  var value: FznExpr = nil
  if p.tryEat(TkEq):
    value = p.parseExpr()

  discard p.expect(TkSemicolon)

  FznVarDecl(
    name: name,
    varType: varType,
    isVar: isVar,
    isArray: isArray,
    arraySize: arraySize,
    annotations: annotations,
    value: value
  )

proc parsePredicate(p: var Parser) =
  ## Parses and discards a predicate declaration
  discard p.eat()  # 'predicate'
  discard p.expect(TkIdent)  # predicate name
  if p.curKind == TkLParen:
    discard p.eat()
    var depth = 1
    while depth > 0 and p.curKind != TkEof:
      if p.curKind == TkLParen: inc depth
      elif p.curKind == TkRParen: dec depth
      if depth > 0: discard p.eat()
    discard p.expect(TkRParen)
  discard p.expect(TkSemicolon)

proc parseConstraint(p: var Parser): FznConstraint =
  discard p.expect(TkConstraint)
  let name = p.expect(TkIdent).strVal
  discard p.expect(TkLParen)
  var args: seq[FznExpr]
  if p.curKind != TkRParen:
    args.add(p.parseExpr())
    while p.tryEat(TkComma):
      args.add(p.parseExpr())
  discard p.expect(TkRParen)
  let annotations = p.parseAnnotations()
  discard p.expect(TkSemicolon)
  FznConstraint(name: name, args: args, annotations: annotations)

proc parseSolve(p: var Parser): FznSolve =
  discard p.expect(TkSolve)
  let annotations = p.parseAnnotations()
  case p.curKind
  of TkSatisfy:
    discard p.eat()
    discard p.expect(TkSemicolon)
    return FznSolve(kind: Satisfy, annotations: annotations)
  of TkMinimize:
    discard p.eat()
    let obj = p.parseExpr()
    discard p.expect(TkSemicolon)
    return FznSolve(kind: Minimize, objective: obj, annotations: annotations)
  of TkMaximize:
    discard p.eat()
    let obj = p.parseExpr()
    discard p.expect(TkSemicolon)
    return FznSolve(kind: Maximize, objective: obj, annotations: annotations)
  else:
    raise newException(ValueError,
      &"FZN parse error at line {p.cur.line}: expected satisfy/minimize/maximize")

proc parseFzn*(src: string): FznModel =
  let tokens = tokenize(src)
  var p = initParser(tokens)

  while p.curKind != TkEof:
    case p.curKind
    of TkPredicate:
      p.parsePredicate()
    of TkConstraint:
      result.constraints.add(p.parseConstraint())
    of TkSolve:
      result.solve = p.parseSolve()
    of TkArray, TkVar, TkInt, TkBool_kw, TkInt_kw:
      let decl = p.parseVarDecl()
      if decl.isVar:
        result.variables.add(decl)
      else:
        result.parameters.add(decl)
    else:
      # Skip unexpected tokens
      discard p.eat()

proc parseFznFile*(filename: string): FznModel =
  parseFzn(readFile(filename))

# ============================================================================
# Helper functions for accessing parsed data
# ============================================================================

proc hasAnnotation*(decl: FznVarDecl, name: string): bool =
  for ann in decl.annotations:
    if ann.name == name: return true
  false

proc getAnnotation*(decl: FznVarDecl, name: string): FznAnnotation =
  for ann in decl.annotations:
    if ann.name == name: return ann
  raise newException(KeyError, &"Annotation '{name}' not found")

proc hasAnnotation*(con: FznConstraint, name: string): bool =
  for ann in con.annotations:
    if ann.name == name: return true
  false
